// <auto-generated/>
using Masa.Blazor.Components.Treeview;
using OneOf.Types;
using StateMachine;
using System.Collections.Concurrent;

namespace StateMachineDemoShared.Pages
{
    public partial class Home
    {

        private ProcedureView pv = default!;
        private FSMExecutor? executor;
        private BlockingCollection<(string, bool)> nodeState = [];

        protected override Task OnInitializedAsync()
        {
            Task.Factory.StartNew(NodeStateCosumer);
            return base.OnInitializedAsync();
        }

        protected override Task OnAfterRenderAsync(bool firstRender)
        {
            if (firstRender)
            {
                pv.Engine.GroupNodeStateChanged += Executor_NodeStateChanged;
                pv.Engine.GroupNodeExitChanged += Executor_NodeExitChanged;
            }
            return base.OnAfterRenderAsync(firstRender);
        }

        private void CreateExecutor()
        {
            if (executor is not null)
            {
                executor.FSMStateChanged -= Executor_FSMStateChanged;
                executor.NodeStateChanged -= Executor_NodeStateChanged;
                executor.NodeExitChanged -= Executor_NodeExitChanged;
            }
            if (pv.Engine.TryGetNode("Start", out IFSMNode StateState))
            {
                if (!pv.Engine.TryGetEvent("EndEvent", out FSMEvent end))
                {
                    end = new FSMEvent("EndEvent");
                }
                executor = new FSMExecutor(StateState, end);
                executor.FSMStateChanged += Executor_FSMStateChanged;
                executor.NodeStateChanged += Executor_NodeStateChanged;
                executor.NodeExitChanged += Executor_NodeExitChanged;
            }
        }


        private async Task NodeStateCosumer()
        {
            string lastNodeName = "";
            foreach ((string nodeName, bool isIn) nstate in nodeState.GetConsumingEnumerable())
            {
                //if (string.IsNullOrEmpty(nstate.nodeName))
                //{
                //    if (!string.IsNullOrEmpty(lastNodeName))
                //    {
                //        if (nstate.isIn)
                //        {
                //            await pc.SetHalfActive(lastNodeName);
                //        }
                //        else
                //        {
                //            await pc.SetInactive(lastNodeName);
                //        }
                //    }
                //    continue;
                //}
                if (string.IsNullOrEmpty(nstate.nodeName))
                {
                    //await pc.SetInactive(lastNodeName);
                }
                else if (nstate.isIn)
                {
                    lastNodeName = nstate.nodeName;
                    await pv.SetActive(nstate.nodeName);
                }
                else
                {
                    await pv.SetInactive(nstate.nodeName);
                }
            }
        }

        private async void Executor_NodeExitChanged(object? sender, string e)
        {
            if (pv is null)
                return;
            //await pc.SetInactive(e);
            nodeState.Add((e, false));
        }

        private void Executor_NodeStateChanged(object? sender, string e)
        {
            if (pv is null)
                return;
            //await pc.SetActive(e);
            nodeState.Add((e, true));
        }

        private void Executor_FSMStateChanged(FSMExecutor arg1, FSMNodeState newState, FSMNodeState oldState)
        {
            switch (newState)
            {
                case FSMNodeState.Uninitialized:
                    break;
                case FSMNodeState.Initialized:
                    canStart = true;
                    canPause = false;
                    canContinue = false;
                    break;
                case FSMNodeState.Proceeding:
                case FSMNodeState.Running:
                    canStart = false;
                    canPause = true;
                    canContinue = false;
                    break;
                case FSMNodeState.Pausing:
                    canStart = false;
                    canPause = false;
                    canContinue = false;
                    break;
                case FSMNodeState.Interrupted:
                case FSMNodeState.Paused:
                    canStart = false;
                    canPause = false;
                    canContinue = true;
                    nodeState.Add(("", true));
                    break;
                case FSMNodeState.Stopping:
                    canStart = false;
                    canPause = false;
                    canContinue = false;
                    break;
                case FSMNodeState.Finished:
                    canStart = true;
                    canPause = false;
                    canContinue = false;
                    nodeState.Add(("", false));
                    break;
                case FSMNodeState.Stoped:
                    canStart = true;
                    canPause = false;
                    canContinue = false;
                    nodeState.Add(("", true));
                    break;
                default:
                    canStart = false;
                    canPause = false;
                    canContinue = false;
                    break;
            }
            InvokeAsync(StateHasChanged);
        }
        private bool canStart = true;
        public void Start()
        {
            CreateExecutor();
            executor?.Restart();
        }

        private bool canPause = false;
        public async Task Pause()
        {
            if (executor is not null)
            {
                await executor.PauseAsync();
            }
        }

        private bool canContinue = false;
        public void Continue()
        {
            if (executor is not null)
            {
                executor.Continue();
            }
        }

        public async Task Stop()
        {
            if (executor is not null)
            {
                await executor.StopAsync();
            }
        }
    }
}