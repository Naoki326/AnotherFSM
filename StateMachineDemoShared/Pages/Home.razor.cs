// <auto-generated/>
using DemoShared.StateMachine;
using Masa.Blazor.Components.Treeview;
using OneOf.Types;
using StateMachine;
using StateMachine.Implement;
using System.Collections.Concurrent;

namespace StateMachineDemoShared.Pages
{
    public partial class Home
    {

        private ProcedureView pv = default!;
        private FSMSingleThreadExecutor? executor;

        protected override Task OnInitializedAsync()
        {
            //Task.Factory.StartNew(NodeStateCosumer);
            return base.OnInitializedAsync();
        }

        string initScript = """
                        def Start(Start)
            {
            	1->NextEvent;
            	Pos:(-107.75, 174);
                Color: "red";
                Type: Start;
                FlowID: 1;
            }
            NextEvent->Start to Check;

            def End(End)
            {
            	1->EndEvent;
            	Pos:(483, 211.5);
                Color: "indigo";
                Type: End;
                FlowID: 2;
            }

            def Start3(Start)
            {
            	1->Next3Event;
            	Pos:(780, 263);
                Color: "red";
                Type: Start;
                FlowID: 24;
            }
            Next3Event->Start3 to Sleep;

            def Check(Accumulate)
            {
            	1->NextEvent;
            	4->BreakEvent;
            	Pos:(168.75, 12);
                Color: "light-blue";
                Type: Accumulate;
                FlowID: 6;
            }
            NextEvent->Check to Parallel;
            BreakEvent->Check to End;

            def Start1(Start)
            {
            	1->Next1Event;
            	Pos:(762, -10.25);
                Color: "red";
                Type: Start;
                FlowID: 11;
            }
            Next1Event->Start1 to Sleep1;

            def End1(End)
            {
            	1->End1Event;
            	Pos:(1347.25, -22.75);
                Color: "cyan";
                Type: End;
                FlowID: 12;
            }

            def Sleep1(Sleep)
            {
            	1->Next1Event;
            	Pos:(1065, -42.25);
                Color: "light-blue";
                Type: Sleep;
                FlowID: 13;
            }
            Next1Event->Sleep1 to End1;

            def Start2(Start)
            {
            	1->Next2Event;
            	Pos:(779, 128);
                Color: "red";
                Type: Start;
                FlowID: 14;
            }
            Next2Event->Start2 to Sleep2;

            def End2(End)
            {
            	1->End2Event;
            	Pos:(1384, 161);
                Color: "cyan";
                Type: End;
                FlowID: 15;
            }

            def Sleep2(Sleep)
            {
            	1->Next2Event;
            	Pos:(1067, 111.75);
                Color: "light-blue";
                Type: Sleep;
                FlowID: 16;
            }
            Next2Event->Sleep2 to End2;

            def Parallel(Parallel)
            {
            	1->NextEvent;
            	5->CancelEvent;
            	Pos:(478, -2.25);
                Color: "indigo";
                Type: Parallel;
                FlowID: 17;
            }
            NextEvent->Parallel to Group;

            def Group(Group)
            {
            	1->NextEvent;
            	5->CancelEvent;
            	Pos:(207, 209);
                Color: "light-blue";
                Type: Group;
                FlowID: 23;
            }
            NextEvent->Group to Check;

            def Sleep(Sleep)
            {
            	1->Next3Event;
            	Pos:(1070, 258.75);
                Color: "light-blue";
                Type: Sleep;
                FlowID: 25;
            }
            Next3Event->Sleep to End3;

            def End3(End)
            {
            	1->End3Event;
            	Pos:(1375.75, 286);
                Color: "cyan";
                Type: End;
                FlowID: 26;
            }
            """;
        private async Task InitAExample()
        {
            await pv.ImportFromScript(initScript);
            (pv.Engine.GetNode("Check") as AccumulateNode).Count = 6;
            (pv.Engine.GetNode("Sleep1") as SleepNode).Duration = 5000;
            (pv.Engine.GetNode("Sleep2") as SleepNode).Duration = 3000;
            (pv.Engine.GetNode("Parallel") as ParallelNode).FSMs = new List<FSMDescribe>()
                {
                    new FSMDescribe(){ StartNode = "Start1", EndEvent = "End1Event" },
                    new FSMDescribe(){ StartNode = "Start2", EndEvent = "End2Event" },
                };
            (pv.Engine.GetNode("Group") as GroupNode).StartName = "Start3";
            (pv.Engine.GetNode("Group") as GroupNode).EndEvent = "End3Event";
            foreach(var state in pv.Engine)
            {
                ResetEventDescriptions(state);
            }
        }

        private void ResetEventDescriptions(IFSMNode state)
        {
            if (state?.GetType().GetCustomAttributes(typeof(FSMNodeAttribute), true).FirstOrDefault() as FSMNodeAttribute is FSMNodeAttribute fsmNodeInfo
                && fsmNodeInfo.Indexes.Length == fsmNodeInfo.EventDescriptions.Length)
            {
                state.EventDescriptions = Enumerable.Range(0, fsmNodeInfo.Indexes.Length)
                    .Select(p => new NodeEventDescription() { Index = fsmNodeInfo.Indexes[p], Description = fsmNodeInfo.EventDescriptions[p] }).ToList();
                foreach (var ed in state.EventDescriptions)
                {
                    if (!pv.Engine.TryGetEvent(ed.Description, out FSMEvent e))
                    { e = new FSMEvent(ed.Description); pv.Engine.AddEvent(e); }
                    state.SetBranchEvent(ed.Index, e);
                }
            }
        }

        protected override Task OnAfterRenderAsync(bool firstRender)
        {
            if (firstRender)
            {
                pv.Engine.GroupNodeStateChanged += Executor_NodeStateChanged;
                pv.Engine.GroupNodeExitChanged += Executor_NodeExitChanged;
            }
            return base.OnAfterRenderAsync(firstRender);
        }

        private void CreateExecutor()
        {
            if (executor is not null)
            {
                executor.FSMStateChanged -= Executor_FSMStateChanged;
                executor.NodeStateChanged -= Executor_NodeStateChanged;
                executor.NodeExitChanged -= Executor_NodeExitChanged;
            }
            if (pv.Engine.TryGetNode("Start", out IFSMNode StateState))
            {
                if (!pv.Engine.TryGetEvent("EndEvent", out FSMEvent end))
                {
                    end = new FSMEvent("EndEvent");
                }
                pv.Engine.ReinitGroupNode();
                executor = new FSMSingleThreadExecutor(StateState, end);
                executor.FSMStateChanged += Executor_FSMStateChanged;
                executor.NodeStateChanged += Executor_NodeStateChanged;
                executor.NodeExitChanged += Executor_NodeExitChanged;
            }
        }

        private async void Executor_NodeExitChanged(object? sender, string e)
        {
            if (pv is null)
                return;
            await pv.SetInactive(e);
            //nodeState.Add((e, false));
        }

        private async void Executor_NodeStateChanged(object? sender, string e)
        {
            if (pv is null)
                return;
            await pv.SetActive(e);
            //nodeState.Add((e, true));
        }

        private void Executor_FSMStateChanged(FSMSingleThreadExecutor arg1, FSMNodeState newState, FSMNodeState oldState)
        {
            switch (newState)
            {
                case FSMNodeState.Uninitialized:
                    break;
                case FSMNodeState.Initialized:
                    canStart = true;
                    canPause = false;
                    canContinue = false;
                    break;
                case FSMNodeState.Proceeding:
                case FSMNodeState.Running:
                    canStart = false;
                    canPause = true;
                    canContinue = false;
                    break;
                case FSMNodeState.Pausing:
                    canStart = false;
                    canPause = false;
                    canContinue = false;
                    break;
                case FSMNodeState.Interrupted:
                case FSMNodeState.Paused:
                    canStart = false;
                    canPause = false;
                    canContinue = true;
                    break;
                case FSMNodeState.Stopping:
                    canStart = false;
                    canPause = false;
                    canContinue = false;
                    break;
                case FSMNodeState.Finished:
                    canStart = true;
                    canPause = false;
                    canContinue = false;
                    break;
                case FSMNodeState.Stoped:
                    canStart = true;
                    canPause = false;
                    canContinue = false;
                    break;
                default:
                    canStart = false;
                    canPause = false;
                    canContinue = false;
                    break;
            }
            InvokeAsync(StateHasChanged);
        }
        private bool canStart = true;
        public async Task Start()
        {
            CreateExecutor();
            if (executor is not null)
            {
                await executor.RestartAsync();
            }
        }

        private bool canPause = false;
        public async Task Pause()
        {
            if (executor is not null)
            {
                await executor.PauseAsync();
            }
        }

        private bool canContinue = false;
        public void Continue()
        {
            if (executor is not null)
            {
                executor.Continue();
            }
        }

        public async Task Stop()
        {
            if (executor is not null)
            {
                await executor.StopAsync();
            }
        }
    }
}